rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Rules for the 'users' collection
    match /users/{userId} {
      // Allow anyone to read user profiles
      allow read: if true; 
      // Allow authenticated users to update/create their own document
      allow update, create: if request.auth != null && request.auth.uid == userId;
      // Disallow deleting user documents
      allow delete: if false; 

      // Allow users to read/write their own inventory subcollection
      match /inventory/{inventoryDocId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }

      // Rules for spoonPoints subcollection within user doc
      match /spoonPoints/{pointsDocId} { // Matches /users/{userId}/spoonPoints/{pointsDocId}
         // Allow owner full read/write access to their own points doc
         allow read, write: if request.auth != null && request.auth.uid == userId;
         
         // Allow any authenticated user to UPDATE (e.g., for awarding points from likes)
         // NOTE: This allows any update, relying on client logic for correctness.
         // Consider Cloud Functions for more granular control if needed.
         allow update: if request.auth != null;
      }
    }

    // Rules for the 'admins' collection
    match /admins/{adminId} {
      // Allow any authenticated user to check if a user is an admin
      allow read: if request.auth != null;
      // Allow only the specific admin to create/update their own doc
      // For now, let's restrict write access significantly.
      // Allow create/update only if the user is the specific admin
      allow write: if request.auth != null && request.auth.uid == 'B9E3AdsEAYSrcfl4yPcT1XqyIfC2' && request.auth.uid == adminId;
      // Disallow delete
      allow delete: if false;
    }

    // Rules for the 'prompts' collection
    match /prompts/{promptId} {
      // Allow reading a single prompt if the user owns it
      allow get: if request.auth != null && request.auth.uid == resource.data.userId;
      // Allow listing prompts only if the query is filtering by the user's own userId
      allow list: if request.auth != null && request.auth.uid == request.query.resource.data.userId;
      // Allow create if the user is authenticated and the new prompt's userId matches their UID
      allow create: if request.auth != null && request.auth.uid == request.resource.data.userId;
      // Allow update if the user is authenticated, owns the prompt, and is not changing the userId
      allow update: if request.auth != null && request.auth.uid == resource.data.userId 
                       && request.resource.data.userId == resource.data.userId;
      // Allow delete if the user is authenticated and owns the prompt
      allow delete: if request.auth != null && request.auth.uid == resource.data.userId;
    }

    // Rules for the 'recipes' collection
    match /recipes/{recipeId} {
      // Allow anyone to read recipes
      allow read: if true;

      // Allow authenticated users to create recipes (ensure they own it)
      // Reverting diagnostic rule, adding userId check back
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;

      // Allow update if user is owner, admin, OR if only the 'likes' field is being changed
      allow update: if request.auth != null && 
                       (
                         // Condition 1: Owner is updating (and not changing owner)
                         (resource.data.userId == request.auth.uid && 
                          request.resource.data.userId == request.auth.uid) 
                         || 
                         // Condition 2: Admin can update any recipe
                         (exists(/databases/$(database)/documents/admins/$(request.auth.uid)) && 
                          get(/databases/$(database)/documents/admins/$(request.auth.uid)).data.active == true)
                         || 
                         // Condition 3: Any authenticated user is ONLY updating the 'likes' field
                         (request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likes']))
                       );

      // Allow recipe owner to delete their own recipe
      allow delete: if request.auth != null && resource.data.userId == request.auth.uid;
    }

    // Rules for the 'spoonPoints' collection
    match /spoonPoints/{userId} {
      // Allow anyone to read spoonPoints (e.g., for leaderboards?)
      allow read: if true;
      // Allow authenticated users to update their own points document
      // Also allow create if the document doesn't exist yet
      allow create, update: if request.auth != null && request.auth.uid == userId;
      // Disallow delete for now
      allow delete: if false;
    }

    // Rules for the 'chats' collection (Pro: save/pin multiple chats)
    match /chats/{chatId} {
      allow read, write: if request.auth != null && request.auth.uid == resource.data.userId;
      allow create: if request.auth != null && request.auth.uid == request.resource.data.userId;
    }

    // Rules for the 'config' collection
    match /config/{documentId} {
        // Allow anyone to read the specific 'marketplace' document
        allow read: if documentId == 'marketplace'; 
        // Deny writes to config documents by default
        allow write: if false;
    }

    // Rules for the 'goodies' collection
    match /goodies/{goodieId} {
        // Allow anyone to read goodies
        allow read: if true;
        // Define write rules if needed (e.g., only admins?)
        allow write: if false; // Default deny write access for now
    }

    // Deny access to any other paths by default
    // It's important that there's no broad allow rule like match /{document=**} { allow read, write: if true; }
    // otherwise it would override these specific rules.
  }
} 